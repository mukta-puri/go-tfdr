package main

import (
	"context"
	"crypto/md5"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"

	tfe "github.com/hashicorp/go-tfe"
	"github.com/tyler-technologies/go-terraform-state-copy/internal/models"
)

var filterConfig models.FilterConfig

var globalResources []string = []string{
	"aws_cloudfront_distribution",
	"aws_cloudfront_origin_access_identity",
	"aws_iam_access_key",
	"aws_iam_policy_document",
	"aws_iam_policy",
	"aws_iam_role_policy_attachment",
	"aws_iam_role_policy",
	"aws_iam_role",
	"aws_iam_user_policy",
	"aws_iam_user",
	"aws_route53_record",
	"keycloak_openid_client",
	"okta_app_oauth",
	"okta_app_group_assignment",
}

var terraformOrgName string = "tyler-technologies-tcp-test"

var token string

func parsestate() {
	token = os.Getenv("TF_TEAM_TOKEN")
	disasterWorkspaceName := "tftest8-1"
	recoveryWorkspaceName := "tftest8-2"

	oldState, err := getTfState(disasterWorkspaceName)
	if err != nil {
		log.Fatal(err)
	}

	filterConfigFile, err := os.Open("filterConfig.json")
	if err != nil {
		log.Fatal(err)
	}
	configByteValue, _ := ioutil.ReadAll(filterConfigFile)

	json.Unmarshal(configByteValue, &filterConfig)

	newResources := filter(oldState.Resources, resourcesToImport)

	newState, err := getTfState(recoveryWorkspaceName)
	if err != nil {
		newState.TerraformVersion = oldState.TerraformVersion
		newState.Version = oldState.Version
	}

	newState.Resources = newResources
	newState.Serial++

	// f, err := os.Create("temp.json")
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// defer f.Close()

	// bytes, err := json.MarshalIndent(newState, "", "\t")
	// if err != nil {
	// 	log.Fatal("Unable to unmarshal state object. Err: ", err)
	// }

	// _, err = f.Write(bytes)

	createTFState(newState, recoveryWorkspaceName)
}

func resourcesToImport(resource models.Resource) models.Resource {
	for _, globalResource := range globalResources {
		if resource.Type == globalResource {
			return resource
		}
	}
	for _, filter := range filterConfig.Filters {
		if resource.Mode == "managed" && resource.Module == filter.Original.Module && resource.Name == filter.Original.Name && resource.Type == filter.Original.Type {
			resource.Module = filter.New.Module
			resource.Name = filter.New.Name
			resource.Type = filter.New.Type

			for k, v := range filter.New.Attributes {
				resource.Instances[0].Attributes[k] = v
			}

			return resource
		}
	}

	return models.Resource{}
}

func filter(vs []models.Resource, f func(models.Resource) models.Resource) []models.Resource {
	vsf := make([]models.Resource, 0)
	for _, v := range vs {
		result := f(v)
		if result.Module != "" {
			vsf = append(vsf, result)
		}
	}
	return vsf
}

func createTFState(state models.State, workspaceName string) {
	config := &tfe.Config{
		Token: token,
	}

	client, err := tfe.NewClient(config)
	if err != nil {
		log.Fatal("Cannot create tfe client. Err: ", err)
	}

	workspace, err := client.Workspaces.Read(context.Background(), terraformOrgName, workspaceName)
	if err != nil {
		log.Fatal("Cannot get workspace. Err: ", err)
	}

	client.Workspaces.Lock(context.Background(), workspace.ID, tfe.WorkspaceLockOptions{})

	stateBytes, err := json.Marshal(state)
	if err != nil {
		log.Fatal("Unable to unmarshal state object. Err: ", err)
	}

	versionMd5Bytes := fmt.Sprintf("%x", md5.Sum(stateBytes))
	versionMd5 := string(versionMd5Bytes[:])
	serial := state.Serial

	base64State := base64.StdEncoding.EncodeToString(stateBytes)

	_, err = client.StateVersions.Create(context.Background(), workspace.ID, tfe.StateVersionCreateOptions{
		MD5:     &versionMd5,
		Serial:  &serial,
		State:   &base64State,
		Lineage: &state.Lineage,
	})
	if err != nil {
		log.Fatal("Unable to create new state version. Err: ", err)
	}
	client.Workspaces.Unlock(context.Background(), workspace.ID)

}

func getTfState(workspaceName string) (models.State, error) {
	config := &tfe.Config{
		Token: token,
	}

	client, err := tfe.NewClient(config)
	if err != nil {
		log.Fatal("Cannot create tfe client. Err: ", err)
	}

	workspace, err := client.Workspaces.Read(context.Background(), terraformOrgName, workspaceName)
	if err != nil {
		log.Fatal("Cannot get workspace. Err: ", err)
	}

	sv, err := client.StateVersions.Current(context.Background(), workspace.ID)
	if err != nil {
		if err.Error() == "resource not found" {
			log.Print("Current state does not exist. Creating new state. Err: ", err)
			return models.State{}, fmt.Errorf("Current state does not exist. Need to create new state: %v", err.Error())
		}
		log.Fatal("Cannot get current state. Err: ", err)
	}

	s, err := client.StateVersions.Download(context.Background(), sv.DownloadURL)
	if err != nil {
		log.Fatal("Cannot download state. Err: ", err)
	}

	var state models.State

	err = json.Unmarshal(s, &state)
	if err != nil {
		log.Fatal("Cannot unmarshal state json. Err: ", err)
	}

	return state, nil
}
